### 给你一个长度为 n 的数组(元素均为正整数)，其中只有一个数字出现了大于等于 n/2 次（即众数），问如何使用优秀的时空复杂度快速找到这个数字

### 解法一 使用对象哈希法
> 1. 初始化哈希对象计数器
> 2. 遍历数组元素，如果对象计数器包含则将属性加1，否则初始化该属性为1
> 3. 比对当前的属性值和计数器大小，如果大于计数器大小，则更新计数器同时保存当前属性(元素)
> 4. 运算结果即为出现大于n/2次的"众数"，时间复杂度为O(n), 空间复杂度为O(n)

### 解法二 使用数组排序法
> 1. 将数组所有元素进行递增/递减排序，则小标[n/2]的元素一定为“众数”
> 2. 对数组长度为奇数的情况，如：{0, 1, 2, 3, 4}, 此时长度为5，如果是众数(至少包含3个)，即众数可能会出现在(0,1,2),(1,2,3),(2,3,4)三种可能的组合位，则位置2即一定会出现的位置，即：5/2(注意向下取整)
> 3. 对数组长度为偶数的情况，如：{0, 1, 2, 3}, 此时长度为4，如果是众数(至少包含2个)，即众数可能会出现在(0,1),(1,2),{2,3}两种可能的组合位，则位置1和2都可能出现的位置，综合2则位置2即一定会出现的位置：4/2(无需取整)
> 4. 因此无论如何众数的下标位置都是n/2(注意向下取整)，时间复杂度为O(nlog(n)), 空间复杂度为O(nlog(n))

### 解法三 使用分治递归法
> 1. 假设 a 是数组的“众数”，不妨将数组分为两部分，则 a 必定是其中一部分的"众数"
> 2. 使用递归算法分别计算左右两部分的众数 a1 和 a2,然后再从 a1 和 a2 中选出正确的“众数”
> 3. 如果左右两边求解的众数 a1 和 a2 相同，则直接返回，否则继续
> 4. 直到所有的左右两边子数组长度变为1，或一边变为1则将两边合并再继续求解，时间复杂度为O(nlog(n)), 空间复杂度为O(nlog(n))